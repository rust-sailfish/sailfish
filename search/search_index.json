{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Sailfish Documentation!","text":"<p>Sailfish is a simple, small, and extremely fast template engine for Rust. This documentation guides you how to get started with sailfish.</p> <p>This documentation mainly focuses on concepts of the library, general usage, and template syntax. If you've read this documentation and need more specific information, you might want to read the sailfish API docs.</p>"},{"location":"#why-sailfish","title":"Why Sailfish ?","text":"<p>There are many libraries for template rendering in Rust. Among those libraries, sailfish aims at rapid development and rapid rendering. Sailfish has many features that other libraries might not support.</p> <ul> <li>Write a Rust code directly inside templates, supporting many Rust syntax (struct definition, closure, macro invocation, etc.)</li> <li>Built-in filters</li> <li>Minimal dependencies (&lt;15 crates in total)</li> <li>Extremely fast (See benchmarks)</li> <li>Template rendering is always type-safe because templates are statically compiled.</li> <li>Syntax highlighting (vscode, vim)</li> </ul>"},{"location":"#upcoming-features","title":"Upcoming features","text":"<p>Since sailfish is on early stage of development, there are many upcoming features that is not supported yet. You can find many RFCs in my repository. These RFC include:</p> <ul> <li><code>Template</code> trait (which does not consume itself)</li> <li>Template inheritance (block, partials, etc.)</li> </ul> <p>If you have any idea about them or want to implement that feature, please send a comment on the issue!</p>"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2020 Ryohei Machida</p> <p>This project is MIT licensed</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prepare-the-template-file","title":"Prepare the template file","text":"<p>Create a new directory named <code>templates</code> in the same directory as <code>Cargo.toml</code>. Copy the following contents and paste it to a new file named <code>templates/hello.stpl</code>.</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;% for msg in &amp;messages { %&gt;\n      &lt;div&gt;&lt;%= msg %&gt;&lt;/div&gt;\n    &lt;% } %&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now your project structure should be like this:</p> <pre><code>Cargo.toml\nsrc/\n    (Source files)\ntemplates/\n    hello.stpl\n</code></pre>"},{"location":"getting-started/#render-the-template","title":"Render the template","text":"<ol><li>Import the sailfish crates:</li></ol> <pre><code>use sailfish::TemplateSimple;\n</code></pre> <ol><li>Define the template struct to be rendered:</li></ol> <pre><code>#[derive(TemplateSimple)]  // automatically implement `TemplateSimple` trait\n#[template(path = \"hello.stpl\")]  // specify the path to template\nstruct HelloTemplate {\n    // data to be passed to the template\n    messages: Vec&lt;String&gt;,\n}\n</code></pre> <ol><li>Render the data with <code>render_once()</code> method.</li></ol> <pre><code>fn main() {\n    let ctx = HelloTemplate {\n        messages: vec![String::from(\"foo\"), String::from(\"bar\")],\n    };\n\n    // Now render templates with given data\n    println!(\"{}\", ctx.render_once().unwrap());\n}\n</code></pre> <p>That's it!</p> <p>You can find more examples in the example directory in the sailfish repository.</p>"},{"location":"installation/","title":"Installation","text":"<p>In order to use sailfish templates, you have add two dependencies in your <code>Cargo.toml</code>.</p> <pre><code>[dependencies]\nsailfish = \"0.9.1\"\n</code></pre>"},{"location":"installation/#feature-flags","title":"Feature Flags","text":"<p>Sailfish accepts the following feature flags</p> Feature Description derive enable derive macros (enabled by default) json enable <code>json</code> filter perf-inline Add more <code>#[inline]</code> attributes. This may improve rendering performance, but generates a bit larger binary (enabled by default)"},{"location":"options/","title":"Configuration","text":""},{"location":"options/#derive-options","title":"Derive options","text":"<p>You can control the rendering behaviour via <code>template</code> attribute.</p> <pre><code>#[derive(TemplateSimple)]\n#[template(path = \"template.stpl\", escape = false)]\nstruct TemplateStruct {\n    ...\n}\n</code></pre> <p><code>template</code> attribute accepts the following options.</p> <ul> <li><code>path</code>: path to template file. This options is always required.</li> <li><code>escape</code>: Enable HTML escaping (default: <code>true</code>)</li> <li><code>delimiter</code>: Replace the '%' character used for the tag delimiter (default: '%')</li> <li><code>rm_whitespace</code>: try to strip whitespaces as much as possible without collapsing HTML structure (default: <code>false</code>). This option might not work correctly if your templates have inline <code>script</code> tag.</li> </ul> <p>You can split the options into multiple <code>template</code> attributes.</p> <pre><code>#[derive(TemplateSimple)]\n#[template(path = \"template.stpl\")]\n#[template(delimiter = '?')]\n#[template(rm_whitespace = true)]\nstruct TemplateStruct {\n    ...\n}\n</code></pre>"},{"location":"options/#configuration-file","title":"Configuration file","text":"<p>Sailfish allows global and local configuration in a file named <code>sailfish.toml</code>. Sailfish looks for this file in same directory as <code>Cargo.toml</code> and all parent directories. If, for example, <code>Cargo.toml</code> exists in <code>/foo/bar/baz</code> directory, then the following configuration files would be scanned in this order.</p> <ul> <li><code>/foo/bar/baz/sailfish.toml</code></li> <li><code>/foo/bar/sailfish.toml</code></li> <li><code>/foo/sailfish.toml</code></li> <li><code>/sailfish.toml</code></li> </ul> <p>If a key is specified in multiple configuration files, the value in the deeper directory takes precedence over ancestor directories.</p> <p>If a key is specified in both configuration file and derive options, then the value specified in the derive options takes precedence over the configuration file.</p>"},{"location":"options/#configuration-file-format","title":"Configuration file format","text":"<p>Configuration files are written in the TOML 0.5 format. Here is the default configuration:</p> <pre><code>template_dirs = [\"templates\"]\nescape = true\ndelimiter = \"%\"\n\n[optimizations]\nrm_whitespace = false\n</code></pre> <p>You can specify another template directory in <code>template_dirs</code> option. Other options are same as derive options.</p> <p>You can also embed environment variables in <code>template_dirs</code> paths by wrapping the variable name with <code>${</code> and <code>}</code> like <code>${MY_ENV_VAR}</code>:</p> <pre><code>template_dirs = [\"${CI}/path/to/project/${MYVAR}/templates\"]\n</code></pre>"},{"location":"syntax/filters/","title":"Filters","text":"<p>Filters are used to format the rendered contents.</p> <p>Example:</p> TemplateResult <pre><code>message: &lt;%= \"foo\\nbar\" | dbg %&gt;\n</code></pre> <pre><code>message: &amp;quot;foo\\nbar&amp;quot;\n</code></pre> <p>Note</p> <p>Since <code>dbg</code> filter accepts <code>&lt;T: std::fmt::Debug&gt;</code> types, that type isn't required to implement <code>Render</code> trait. That means you can pass the type which doesn't implement <code>Render</code> trait.</p>"},{"location":"syntax/filters/#syntax","title":"Syntax","text":"<ul> <li>Apply filter and HTML escaping</li> </ul> <pre><code>&lt;%= expression | filter %&gt;\n</code></pre> <ul> <li>Apply filter only</li> </ul> <pre><code>&lt;%- expression | filter %&gt;\n</code></pre>"},{"location":"syntax/filters/#built-in-filters","title":"Built-In Filters","text":"<p>Built-In filters can be found in <code>sailfish::runtime::filter</code> module.</p>"},{"location":"syntax/filters/#useful-filters","title":"Useful Filters","text":"<p>You can also use the Display filter to do things like format a date, or a UUID.</p> <ul> <li>Easily Display A Date</li> </ul> TemplateResult <pre><code>&lt;span&gt;&lt;%= chrono::NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap().format(\"around %l %p on %b %-d\") | disp %&gt;&lt;/span&gt;\n</code></pre> <pre><code>&lt;span&gt;around 11 PM on Sep 5&lt;/span&gt;\n</code></pre> <ul> <li>Easily Display A UUID</li> </ul> TemplateResult <pre><code>&lt;span&gt;&lt;%= uuid::Uuid::new_v4().urn() | disp %&gt;&lt;/span&gt;\n</code></pre> <pre><code>&lt;span&gt;urn:uuid:c3602585-a9a1-43f5-b0e6-8bc05d5444dd&lt;/span&gt;\n</code></pre>"},{"location":"syntax/includes/","title":"Includes","text":"<p>You can also include another template inside templates using <code>include!</code> macro.</p> <p>Consider the following example.</p> <ul> <li><code>templates/header.stpl</code></li> </ul> <pre><code>&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;\n&lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;\n</code></pre> <ul> <li><code>templates/index.stpl</code></li> </ul> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;% include!(\"./header.stpl\"); %&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    Main contents\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Then you can see the <code>header.stpl</code> is embedded in the output.</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;\n&lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    Main contents\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Like <code>std::include!</code> macro in Rust, the provided path is interpreted as a relative path to the current template file.</p> <p>Warning</p> <p>The path format is platform-specific. You must use <code>\\</code> character as a separator on Windows.</p>"},{"location":"syntax/overview/","title":"Template Syntax Overview","text":""},{"location":"syntax/overview/#tags","title":"Tags","text":"<ul> <li><code>&lt;% %&gt;</code>: Inline tag, you can write Rust code inside this tag</li> <li><code>&lt;%= %&gt;</code>: Evaluate the Rust expression and outputs the value into the template (HTML escaped)</li> <li><code>&lt;%- %&gt;</code>: Evaluate the Rust expression and outputs the unescaped value into the template</li> <li><code>&lt;%+ %&gt;</code>: Evaluate the Rust expression producing a <code>TemplateOnce</code> value, and render that value into the template</li> <li><code>&lt;%# %&gt;</code>: Comment tag</li> <li><code>&lt;%%</code>: Outputs a literal '&lt;%'</li> </ul>"},{"location":"syntax/overview/#condition","title":"Condition","text":"<pre><code>&lt;% if messages.is_empty() { %&gt;\n  &lt;div&gt;No messages&lt;/div&gt;\n&lt;% } %&gt;\n</code></pre>"},{"location":"syntax/overview/#loop","title":"loop","text":"<pre><code>&lt;% for (i, msg) in messages.iter().enumerate() { %&gt;\n  &lt;div&gt;&lt;%= i %&gt;: &lt;%= msg %&gt;&lt;/div&gt;\n&lt;% } %&gt;\n</code></pre>"},{"location":"syntax/overview/#includes","title":"Includes","text":"<pre><code>&lt;% include!(\"path/to/template\"); %&gt;\n</code></pre>"},{"location":"syntax/overview/#filters","title":"Filters","text":"<pre><code>&lt;%= message | upper %&gt;\n</code></pre> <pre><code>{\n    \"id\": &lt;%= id %&gt;\n    \"comment\": &lt;%- comment | json %&gt;\n}\n</code></pre>"},{"location":"syntax/tags/","title":"Tags","text":""},{"location":"syntax/tags/#code-block","title":"Code block","text":"<p>You can write Rust statement inside <code>&lt;% %&gt;</code> tag.</p> TemplateResult <pre><code>&lt;%\nlet mut total = 0;\nfor i in 1.. {\n    total += i;\n    if i &gt; 100 {\n        break;\n    }\n}\n%&gt;\n&lt;div&gt;total = &lt;%= total %&gt;&lt;/div&gt;\n</code></pre> <pre><code>&lt;div&gt;total = 105&lt;/div&gt;\n</code></pre> <p>Note</p> <p>Make sure that you cannot omit braces, parenthesis, and semicolons.</p> <p>Sailfish is smart enough to figure out where the code block ends, so you can even include <code>%&gt;</code> inside Rust comments or string literals.</p> TemplateResult <pre><code>&lt;% /* Tag does not ends at %&gt;! */ %&gt;\n</code></pre> <pre><code>\n</code></pre> <p>If you need to simply render <code>&lt;%</code> character, you can escape it, or use evaluation block (described below).</p> TemplateResult <pre><code>&lt;%% is converted into &lt;%- \"&lt;%\" %&gt; character.\n</code></pre> <pre><code>&lt;% is converted into &lt;% character\n</code></pre> <p>Although almost all Rust statement is supported, the following statements inside templates may cause a strange compilation error.</p> <ul> <li>Function/Macro definition that render some contents</li> <li><code>impl</code> item</li> <li>Macro call which defines some local variable.</li> <li>Macro call which behaviour depends on the path to source file</li> <li>Generator expression (yield)</li> </ul>"},{"location":"syntax/tags/#evaluation-block","title":"Evaluation block","text":"<p>Rust expression inside <code>&lt;%= %&gt;</code> tag is evaluated and the result will be rendered.</p> TemplateResult <pre><code>&lt;% let a = 1; %&gt;&lt;%= a + 2 %&gt;\n</code></pre> <pre><code>3\n</code></pre> <p>If the result contains <code>&amp;\"'&lt;&gt;</code> characters, sailfish replaces these characters with the equivalent html.</p> <p>If you want to render the results without escaping, you can use <code>&lt;%- %&gt;</code> tag or configure sailfish to not escape by default.</p> TemplateResult <pre><code>&lt;div&gt;\n  &lt;%- \"&lt;h1&gt;Hello, World!&lt;/h1&gt;\" %&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>&lt;div&gt;\n  &lt;h1&gt;Hello, World!&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>Note</p> <p>Evaluation block does not return any value, so you cannot use the block to pass the render result to another code block. The following code is invalid.</p> <pre><code>&lt;% let result = %&gt;&lt;%= 1 %&gt;&lt;% ; %&gt;\n</code></pre>"},{"location":"syntax/tags/#component-block","title":"Component block","text":"<p>Rust expression inside <code>&lt;%+ %&gt;</code> tag is evaluated and then rendered by calling its <code>render_once()</code> method. If the value does not have an appropriate method, a compile-time error will be reported.</p> <p>This makes it easy to use types which are <code>TemplateOnce</code> as components which can be embedded into other templates.</p> Template ATemplate BResult <pre><code>&lt;strong&gt;A &lt;%= val %&gt;&lt;/strong&gt;\n</code></pre> <pre><code>B &lt;%+ A { val: \"example\" } %&gt;\n</code></pre> <pre><code>B &lt;strong&gt;A example&lt;/strong&gt;\n</code></pre>"}]}